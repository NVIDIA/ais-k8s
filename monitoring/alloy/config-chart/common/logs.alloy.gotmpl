{{- if and .Values.remote .Values.logs .Values.logs.remoteEndpoint }}
otelcol.exporter.otlphttp "remote_logs_export" {
  client {
    auth = otelcol.auth.oauth2.azure_oidc.handler
    endpoint = "{{ .Values.logs.remoteEndpoint }}"
  }
}

// To reduce network traffic, only send specific logs to remote
otelcol.processor.filter "remote_logs_only" {
  logs {
    log_record = [
      `not (resource.attributes["service.namespace"] == "ais" or
       resource.attributes["service.namespace"] == "kube-system" or
       resource.attributes["service.namespace"] == "monitoring" or
       resource.attributes["service.namespace"] == "ais-operator-system")`,
    ]
  }

  output {
    logs = [otelcol.exporter.otlphttp.remote_logs_export.input]
  }
}
{{- end }}

{{- if .Values.logs.localGateway }}

otelcol.exporter.loki "local_loki" {
  attributes_to_labels = ["cluster", "service.name", "service.namespace", "k8s.pod.name"]
  forward_to = [loki.write.local.receiver]
}

loki.write "local" {
  endpoint {
    url = {{ .Values.logs.localGateway | quote }}
  }
}
{{- end }}

// Ingest logs from K8s pods on the same node as this alloy pod

discovery.kubernetes "pod" {
  role = "pod"
  selectors {
    role = "pod"
    field = "spec.nodeName=" + coalesce(sys.env("HOSTNAME"), constants.hostname)
  }
}

// Convert discovery labels from attributes to loki labels which will later become OTLP attributes

discovery.relabel "pod_logs" {
  targets = discovery.kubernetes.pod.targets

  // K8s attributes
  rule {
    source_labels = ["__meta_kubernetes_namespace"]
    target_label  = "k8s_namespace_name"
    action        = "replace"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_name"]
    target_label  = "k8s_pod_name"
    action        = "replace"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_container_name"]
    target_label  = "k8s_container_name"
    action        = "replace"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_controller_kind"]
    target_label  = "k8s_controller_kind"
    action        = "replace"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_controller_name"]
    target_label  = "k8s_controller_name"
    action        = "replace"
  }

  // Service attributes
  rule {
    source_labels = ["__meta_kubernetes_namespace"]
    target_label  = "service_namespace"
    action        = "replace"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
    target_label  = "service_name"
    action        = "replace"
  }

  // Additional backwards compatible metadata
  rule {
    source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_component"]
    target_label  = "component"
    action        = "replace"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_node_name"]
    target_label  = "host_name"
    action        = "replace"
  }

  // Non-indexed metadata
  rule {
    source_labels = ["__meta_kubernetes_pod_container_image"]
    target_label  = "k8s_container_image"
    action        = "replace"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_container_port_number"]
    target_label  = "k8s_container_port"
    action        = "replace"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_phase"]
    target_label  = "k8s_pod_phase"
    action        = "replace"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_ready"]
    target_label  = "k8s_pod_ready"
    action        = "replace"
  }
}


// Use Loki source from the discovery targets then convert to OTLP logs 

loki.source.kubernetes "loki_pod_logs" {
  targets    = discovery.relabel.pod_logs.output
  forward_to = [otelcol.receiver.loki.pod_logs.receiver]
}

otelcol.receiver.loki "pod_logs" {
  output {
    logs = [otelcol.processor.resourcedetection.logs_cloud.input]
  }
}

// Process log labels in OTLP format

// Inject attributes from the node (can be extended for discovery in different environments)

otelcol.processor.resourcedetection "logs_cloud" {
  detectors = ["env"]
  output {
    logs = [otelcol.processor.transform.convert_attr.input]
  }
}

// Convert Loki attributes to indexed resource attributes in OTLP format 

otelcol.processor.transform "convert_attr" {
  log_statements {
    context = "log"

    statements = [
      // k8s namespace
      "set(resource.attributes[\"k8s.namespace.name\"], attributes[\"k8s_namespace_name\"])",
      "delete_key(attributes, \"k8s_namespace_name\")",

      // k8s pod
      "set(resource.attributes[\"k8s.pod.name\"], attributes[\"k8s_pod_name\"])",
      "delete_key(attributes, \"k8s_pod_name\")",

      // k8s container
      "set(resource.attributes[\"k8s.container.name\"], attributes[\"k8s_container_name\"])",
      "delete_key(attributes, \"k8s_container_name\")",
      "set(resource.attributes[\"k8s.container.image\"], attributes[\"k8s_container_image\"])",
      "delete_key(attributes, \"k8s_container_image\")",
      "set(resource.attributes[\"k8s.container.port\"], attributes[\"k8s_container_port\"])",
      "delete_key(attributes, \"k8s_container_port\")",

      // service*
      "set(resource.attributes[\"service.namespace\"], attributes[\"service_namespace\"])",
      "delete_key(attributes, \"service_namespace\")",
      "set(resource.attributes[\"service.name\"], attributes[\"service_name\"])",
      "delete_key(attributes, \"service_name\")",
      "set(resource.attributes[\"service.instance.id\"], attributes[\"instance\"])",
      "delete_key(attributes, \"instance\")",

      // host
      "set(resource.attributes[\"host.name\"], attributes[\"host_name\"])",
      "delete_key(attributes, \"host_name\")",

      // pod state
      "set(resource.attributes[\"k8s.pod.phase\"], attributes[\"k8s_pod_phase\"])",
      "delete_key(attributes, \"k8s_pod_phase\")",
      "set(resource.attributes[\"k8s.pod.ready\"], attributes[\"k8s_pod_ready\"])",
      "delete_key(attributes, \"k8s_pod_ready\")",

      //job
      "set(resource.attributes[\"k8s.job.name\"], attributes[\"job\"])",
      "delete_key(attributes, \"job\")",

      //component
      "set(resource.attributes[\"component\"], attributes[\"component\"])",
      "delete_key(attributes, \"component\")",


    ]
  }

  output {
    logs = [otelcol.processor.transform.insert_cluster_attr.input]
  }
}

// Set "cluster" resource attribute to explicit remote label or fallback to "local"

otelcol.processor.transform "insert_cluster_attr" {
  log_statements {
    context = "resource"

    statements = [
    {{- if and .Values.remote .Values.remote.label }}
      "set(attributes[\"cluster\"], \"{{ .Values.remote.label }}\")",
    {{- else }}
      "set(attributes[\"cluster\"], \"local\")",
    {{- end }}
    ]
  }

  output {
    logs = [otelcol.processor.transform.k8s_workload_from_controller.input]
  }
}

// Set specifically indexed resource attributes from the controller metadata

otelcol.processor.transform "k8s_workload_from_controller" {
  log_statements {
    context = "log"
    statements = [
      // ReplicaSet
      `set(resource.attributes["k8s.replicaset.name"], attributes["k8s_controller_name"])
         where attributes["k8s_controller_kind"] == "ReplicaSet"`,
      `delete_key(attributes, "k8s_controller_name")
         where attributes["k8s_controller_kind"] == "ReplicaSet"`,
      `delete_key(attributes, "k8s_controller_kind")
         where attributes["k8s_controller_kind"] == "ReplicaSet"`,

      // Deployment
      `set(resource.attributes["k8s.deployment.name"], attributes["k8s_controller_name"])
         where attributes["k8s_controller_kind"] == "Deployment"`,
      `delete_key(attributes, "k8s_controller_name")
         where attributes["k8s_controller_kind"] == "Deployment"`,
      `delete_key(attributes, "k8s_controller_kind")
         where attributes["k8s_controller_kind"] == "Deployment"`,

      // StatefulSet
      `set(resource.attributes["k8s.statefulset.name"], attributes["k8s_controller_name"])
         where attributes["k8s_controller_kind"] == "StatefulSet"`,
      `delete_key(attributes, "k8s_controller_name")
         where attributes["k8s_controller_kind"] == "StatefulSet"`,
      `delete_key(attributes, "k8s_controller_kind")
         where attributes["k8s_controller_kind"] == "StatefulSet"`,

      // DaemonSet
      `set(resource.attributes["k8s.daemonset.name"], attributes["k8s_controller_name"])
         where attributes["k8s_controller_kind"] == "DaemonSet"`,
      `delete_key(attributes, "k8s_controller_name")
         where attributes["k8s_controller_kind"] == "DaemonSet"`,
      `delete_key(attributes, "k8s_controller_kind")
         where attributes["k8s_controller_kind"] == "DaemonSet"`,

      // CronJob
      `set(resource.attributes["k8s.cronjob.name"], attributes["k8s_controller_name"])
         where attributes["k8s_controller_kind"] == "CronJob"`,
      `delete_key(attributes, "k8s_controller_name")
         where attributes["k8s_controller_kind"] == "CronJob"`,
      `delete_key(attributes, "k8s_controller_kind")
         where attributes["k8s_controller_kind"] == "CronJob"`,

      // Job
      `set(resource.attributes["k8s.job.name"], attributes["k8s_controller_name"])
         where attributes["k8s_controller_kind"] == "Job"`,
      `delete_key(attributes, "k8s_controller_name")
         where attributes["k8s_controller_kind"] == "Job"`,
      `delete_key(attributes, "k8s_controller_kind")
         where attributes["k8s_controller_kind"] == "Job"`,
    ]
  }

  output {
    logs = [otelcol.processor.transform.ais_extract_level.input]
  }
}


// Extract level from the body and promote it as metadata for filtering

otelcol.processor.transform "ais_extract_level" {   
  // Need "log" context to use IsMatch on the body
  log_statements {
    context = "log"
    statements = [
      // INFO
      `set(severity_text, "INFO") where resource.attributes["service.namespace"] == "ais" and resource.attributes["service.name"] == "ais" and IsMatch(body, "^[ \t]*I\\b.*")`,
      `set(severity_number, 9) where resource.attributes["service.namespace"] == "ais" and resource.attributes["service.name"] == "ais" and IsMatch(body, "^[ \t]*I\\b.*")`,

      // WARN
      `set(severity_text, "WARN") where resource.attributes["service.namespace"] == "ais" and resource.attributes["service.name"] == "ais" and IsMatch(body, "^[ \t]*W\\b.*")`,
      `set(severity_number, 13) where resource.attributes["service.namespace"] == "ais" and resource.attributes["service.name"] == "ais" and IsMatch(body, "^[ \t]*W\\b.*")`,

      // ERROR
      `set(severity_text, "ERROR") where resource.attributes["service.namespace"] == "ais" and resource.attributes["service.name"] == "ais" and IsMatch(body, "^[ \t]*E\\b.*")`,
      `set(severity_number, 17) where resource.attributes["service.namespace"] == "ais" and resource.attributes["service.name"] == "ais" and IsMatch(body, "^[ \t]*E\\b.*")`,
    ]
  }

  output {
    logs = [otelcol.processor.filter.drop_coredns.input]
  }
}

otelcol.processor.filter "drop_coredns" {
  logs {
    log_record = [`resource.attributes["service.namespace"] == "kube-system" and
        resource.attributes["k8s.container.name"] == "coredns" and
        IsMatch(body, "No files matching import glob pattern")`,
    ]
  }

  output {
    logs = [otelcol.processor.transform.drop_loki_labels.input]
  }
}

otelcol.processor.transform "drop_loki_labels" {
  log_statements {
    context = "log"
    statements = [
      "delete_key(attributes, \"loki.attribute.labels\")",
    ]
  }

  output {
    logs = [otelcol.processor.batch.default.input]
  }
}

otelcol.processor.batch "default" {
  output {
    logs = [
      {{- if .Values.logs.localGateway }}
      otelcol.exporter.loki.local_loki.receiver,
      {{- end }}
      {{- if and .Values.remote .Values.logs .Values.logs.remoteEndpoint }}
      otelcol.processor.filter.remote_logs_only.input,
      {{- end }}
    ]
  }
}